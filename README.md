## First Come, First Served 

**First Come, First Served**는 **대규모 트래픽 환경**에서 **상품 구매 서비스**와 **실시간 조회수 랭킹**을 제공하는  
**이커머스 프로젝트**입니다.

## 프로젝트 핵심 목표

1. **대규모 트래픽 대응**
   - Redisson을 사용해 락을 구현하여 동시성 이슈 제어.

2. **실시간 조회수 조회 성능 최적화**
   - Redis 기반 캐싱으로 실시간 상품 조회수 응답 시간 30% 감소.
   - 해시 키와 TTL 설정으로 어뷰징 방지. 

## KEY Summary

### 🛒 **동시성 이슈 제어, 성능 개선 : 응답 시간 30% 감소 **

---

1. **한 줄 요약**    
   - 대규모 트래픽 환경에서 데이터 정합성 유지
   - 레디스 캐싱으로 조회 성능 향상

   ![성능 개선 이미지]

2. **도입 배경**  
   - 트래픽이 몰리고 동시 구매가 많이 발생하는 상품의 구매를 정확히 처리
   - 인기 상품의 조회수와 랭킹을 실시간으로 업데이트 하는 기능 필요

3. **기술적 선택지**  

   1. **Redisson 분산 락 적용**  
      - 상품 주문이 동시에 이루어질 때 트랜잭션 커밋 시점과 Synchronized 의 시점 차이로 상품 재고 데이터 정합성 깨짐

   2. **Redis 캐싱**  
      - 일일 실시간 상품 조회수와 랭킹 제공
      - 조회수 UPDATE 쿼리가 매번 실행되어 과도한 DB 접근 상황 발생
      - 여러 상품의 조회수를 한 번에 업데이트 할 수 있는 쿼리 필요

   **결론:** Redisson 기반 분산락 적용, 조회수 캐싱 및 batch로 UPDATE 쿼리 묶어 DB로 한번에 전송.

---

### 🛒 **트러블 슈팅 : 락을 적용했지만 상품 주문 시 상품 재고 데이터 정합성 깨지는 상황 - 락 해제 시점과 트랜잭션 커밋 시점 조정**

---

1. **문제**  
   - **락 적용 후 주문 취소 기능**  
     - 중복 취소가 발생해 재고 불일치 오류 발생
   - **락을 적용했지만 주문 상태가 CANCELED로 인식되지 않음**  
   - **주문 상태 업데이트는 JPA의 Dirty Checking에 의존**   

2. **원인**  
   - JPA는 트랜잭션 커밋 시점에 일괄적으로 변경사항을 반영한다.  
     - 스레드 A가 주문 상태를 CANCELED로 바꾸고 커밋되지 않은 상태  
     - 스레드 B가 락을 획득하고 같은 주문을 조회하면 여전히 ORDERED로 조회
     - 중복 취소 가능

3. **해결**  
   - **JPA를 NativeQuery로 변경 시도**  
     - 트랜잭션이 커밋되지 않으면 여전히 다른 트랜잭션에서는 이전 값만 조회함.
   - **Redisson 락 해제 시점 조정**
     - 락을 트랜잭션 커밋 후에 해제되도록 TransactionSynchronizationManager를 통해 처리
     - 하나의 스레드가 트랜잭션 커밋한 후 다른 스레드가 락을 획득할 수 있도록 설정.


## 적용 기술


<details>
<summary><b>📦 적용 기술 상세보기</b></summary>
<br>

**분산 락 구현**
1. **Redisson**  
   - **적용 위치**: Redis 기반 분산 락 시스템
   - **사용 이유**: 대규모 트래픽 상황에서 동시에 발생하는 주문 요청으로부터 상품 재고 데이터 보호.  
---

**데이터베이스 및 캐싱**
1. **Redis**  
   - **적용 위치**: 캐시 서버  
   - **사용 이유**: 실시간 상품 조회수, 랭킹 저장. Token 저장.
---

</details>

## 주요 기능

### 🛒 **상품 주문: Redisson 분산 락 적용**
- 대용량 트래픽 상황에서 동시성 이슈 제어.
- Redisson RLock으로 락 자동 관리, 안정적인 락 구현.
---

### 🛒 **상품 조회수, 랭킹 조회**
- 상품을 조회할 때마다 조회수 UPDATE 쿼리를 추가로 날려야 하는 상황을 막기 위해 캐싱 활용.
- 응답시간 성능 향상.
---

### 🛒 **상품 조회수, 랭킹 업데이트**
- 각 상품별 UPDATE 쿼리 실행 횟수를 줄이고 네트워크, DB 부하 완화.
- UPDATE 쿼리를 개별 생성하되, 일정 단위 (batch size)로 묶어 한번에 DB로 전송.
---

### 🛒 **JWT 인증**
- 상태를 저장하지 않는 JWT의 특성 때문에 로그아웃, 토큰 재발급 관리를 위해 Redis 활용.
- Refresh Token을 저장해 토큰 갱신, 로그아웃 or 탈퇴 시 access token 블랙리스트 처리.
---
## 기술적 고도화

<details>
<summary><b>🛒 Redis 락 구현으로 동시성 이슈 제어 </b></summary>

#### Redisson 분산락을 채택한 이유

1. **Lettuce의 장점**  
   Lettuce는 락을 얻을 때까지 루프를 돌며 기다리는 스핀락 구조.
   빠르게 락을 재시도할 수 있어 짧은 시간 내 락 해제가 예상될 때 효과적이다.
   - 응답이 빠르다.

3. **Redisson을 채택한 이유**  
   Lettuce 기반 분산락 + Lua 스크립트를 활용해 세밀한 락 제어와 원자성 보장을 구현하려 했으나,
   프로젝트 일정이 촉박해 안정적인 구현이 어려움.
   - 안정적이고 검증된 방식인 Redisson의 RLock을 채택.


</details>

---

## 역할 분담 및 협업 방식

### **Detail Role**

| 이름   | 포지션   | 담당(개인별 기여점)                                                                                                            | Github 링크                       |
|--------|----------|-----------------------------------------------------------------------------------------------------------------------------|-----------------------------------|
| 임호진 | 팀장     | ▶ 공통 응답, 예외 처리 ▶ Redis를 통한 조회수, 랭킹 캐싱 | https://github.com/hojin915 |
| 김민성 | 팀원     | ▶ Spring Security 인증/인가 ▶ Auth 및 통합 테스트                       | https://github.com/urzn  |
| 유진원 | 팀원     | ▶ **장바구니**: CRUD 및 Redisson을 통한 분산 락 적용      | https://github.com/Jindnjs  |
| 윤희준 | 팀원     | ▶ **상품**: CRUD 및 Redisson을 통한 분산 락 적용     | https://github.com/planbsoho |
| 이동근 | 팀원     | ▶ **주문**: CRUD 및 Redisson을 통한 분산 락 적용     | https://github.com/DG0702   |

---

### **Ground Rule**

🛒 **협업 시 소통은 언제나**  
- 문제가 생기면 바로 대화나 회의 진행.

🛒 **Task 진행 현황 공유**  
- 노션에 진행 예정, 진행 중, 완료 Task 구분 해 진척도 공유.

🛒 **Github Issue, PR 사용**  
- 기능 별 이슈 생성하고 PR 리뷰 필수.

## 성과 및 회고

### 잘된 점
- **동시성 이슈 제어**  
  - Lock을 적해 이커머스에서 정확한 처리가 필요한 재고 데이터 정합성 오류를 방지하고 안정적인 주문 처리 구현.
  - 조회수 캐싱으로 응답 시간 단축.

- **구체적인 소통과 협업**
   - 매일 스크럼을 통해 문제를 빠르게 공유하고, 진척도와 구현 방식을 구체적으로 논의함으로써 협업의 밀도를 높임.
---

### 아쉬운 점
- **구현 방식 미확정으로 설계 구조 불안정**  
  - 초기 단계에서 구현 방식을 명확히 정하지 않고 기능 개발을 시작해 흐름이 원활하지 못한 부분이 있었음.

---
